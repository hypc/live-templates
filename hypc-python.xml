<templateSet group="hypc-python">
  <template name="hh:python:testcase" value="class $class$(TestCase):&#10;&#10;    def setUp(self):&#10;        super($class$, self).setUp()&#10;&#10;    def test(self):&#10;        pass$end$&#10;" description="" toReformat="false" toShortenFQNames="true">
    <variable name="class" expression="" defaultValue="&quot;Testcase&quot;" alwaysStopAt="true" />
    <variable name="end" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="Python" value="true" />
      <option name="Python_Class" value="false" />
    </context>
  </template>
  <template name="hh:python:setup.py" value="import os&#10;from setuptools import setup, find_packages&#10;from setuptools.command.install import install&#10;&#10;# 1.2.0.dev1  # Development release&#10;# 1.2.0a1     # Alpha Release&#10;# 1.2.0b1     # Beta Release&#10;# 1.2.0rc1    # Release Candidate&#10;# 1.2.0       # Final Release&#10;# 1.2.0.post1 # Post Release&#10;# 15.10       # Date based release&#10;# 23          # Serial release&#10;VERSION = '0.0.1a1'&#10;PATH = os.path.dirname(os.path.abspath(__file__))&#10;&#10;# When the project is installed by pip, this is the specification that is used to install its dependencies.&#10;install_requires = []&#10;&#10;&#10;def read(fname):&#10;    return open(os.path.join(PATH, fname)).read()&#10;&#10;&#10;class PostInstallCommand(install):&#10;    def run(self):&#10;        pass&#10;&#10;&#10;setup(&#10;    # This is the name of your project, determining how your project is listed on PyPI.&#10;    name='sample',&#10;    version=VERSION,&#10;    # Give a short and long description for your project. These values will be displayed on PyPI if you publish your project.&#10;    description='',&#10;    long_description=read('README.md'),&#10;    # Give a homepage URL for your project.&#10;    url='',&#10;    # Provide details about the author.&#10;    author='',&#10;    author_email='',&#10;    license='MIT',&#10;    # List keywords that describe your project.&#10;    keywords='',&#10;    # List additional relevant URLs about your project.&#10;    project_urls=[],&#10;    packages=find_packages(exclude=['docs', 'tests*', 'example']),&#10;    install_requires=install_requires,&#10;    # If your project only runs on certain Python versions, setting the `python_requires` argument.&#10;    python_requires='&gt;=3',&#10;    classifiers=[&#10;        # How mature is this project? Common values are&#10;        #   3 - Alpha&#10;        #   4 - Beta&#10;        #   5 - Production/Stable&#10;        'Development Status :: 3 - Alpha',&#10;&#10;        # Indicate who your project is intended for&#10;        'Intended Audience :: Developers',&#10;        'Topic :: Software Development :: Build Tools',&#10;&#10;        # Pick your license as you wish (should match &quot;license&quot; above)&#10;        'License :: OSI Approved :: MIT License',&#10;&#10;        # Specify the Python versions you support here. In particular, ensure&#10;        # that you indicate whether you support Python 2, Python 3 or both.&#10;        'Programming Language :: Python :: 3',&#10;        'Programming Language :: Python :: 3.2',&#10;        'Programming Language :: Python :: 3.3',&#10;        'Programming Language :: Python :: 3.4',&#10;        'Programming Language :: Python :: 3.5',&#10;    ],&#10;    entry_points={&#10;        # You can then let the toolchain handle the work of turning these interfaces into actual scripts.&#10;        'console_scripts': [&#10;            'sample=sample:main',&#10;        ],&#10;    },&#10;    cmd_class={&#10;        'install': PostInstallCommand,&#10;    }&#10;)&#10;$end$" description="" toReformat="false" toShortenFQNames="true">
    <variable name="end" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="Python" value="true" />
      <option name="Python_Class" value="false" />
    </context>
  </template>
  <template name="hh:python:logging" value="logging.basicConfig(&#10;    level='$level$',&#10;    format='[%(asctime)s] [%(process)d:%(thread)d] [%(levelname)s] [%(name)s] [%(pathname)s:%(lineno)d] -- %(message)s',&#10;    datefmt='%Y-%m-%d %H:%M:%S %z',&#10;    handlers=[logging.StreamHandler()]&#10;)&#10;$end$" description="" toReformat="false" toShortenFQNames="true">
    <variable name="level" expression="" defaultValue="&quot;DEBUG&quot;" alwaysStopAt="true" />
    <variable name="end" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="Python" value="true" />
      <option name="Python_Class" value="false" />
    </context>
  </template>
  <template name="hh:python:rsautils" value="# encoding: utf-8&#10;import base64&#10;&#10;from Crypto import Random&#10;from Crypto.Cipher import PKCS1_v1_5 as Cipher&#10;from Crypto.Hash import SHA&#10;from Crypto.PublicKey import RSA&#10;from Crypto.Signature import PKCS1_v1_5 as Signature&#10;&#10;&#10;class RSAUtils(object):&#10;&#10;    @classmethod&#10;    def generate_keys(cls):&#10;        &quot;&quot;&quot;&#10;        :return: private_key and public_key&#10;        :rtype: (str, str)&#10;        &quot;&quot;&quot;&#10;        key = RSA.generate(2048)&#10;        private_key = key.exportKey().decode()&#10;        public_key = key.publickey().exportKey().decode()&#10;        return private_key, public_key&#10;&#10;    @classmethod&#10;    def sign(cls, message, private_key):&#10;        &quot;&quot;&quot;&#10;        :type message: str | bytes&#10;        :type private_key: str | bytes&#10;        :rtype: str&#10;        &quot;&quot;&quot;&#10;        if isinstance(message, str):&#10;            message = message.encode()&#10;        h = SHA.new(message)&#10;        signer = Signature.new(RSA.importKey(private_key))&#10;        return base64.b64encode(signer.sign(h)).decode()&#10;&#10;    @classmethod&#10;    def verify(cls, message, sign, public_key):&#10;        &quot;&quot;&quot;&#10;        :type message: str | bytes&#10;        :type sign: str | bytes&#10;        :type public_key: str | bytes&#10;        :rtype: bool&#10;        &quot;&quot;&quot;&#10;        if isinstance(message, str):&#10;            message = message.encode()&#10;        sign = base64.b64decode(sign)&#10;        h = SHA.new(message)&#10;        verifier = Signature.new(RSA.importKey(public_key))&#10;        return verifier.verify(h, sign)&#10;&#10;    @classmethod&#10;    def encrypt(cls, message, public_key):&#10;        &quot;&quot;&quot;&#10;        :type message: str | bytes&#10;        :type public_key: str | bytes&#10;        :rtype: str&#10;        &quot;&quot;&quot;&#10;        if isinstance(message, str):&#10;            message = message.encode()&#10;        cipher = Cipher.new(RSA.importKey(public_key))&#10;        return base64.b64encode(cipher.encrypt(message)).decode()&#10;&#10;    @classmethod&#10;    def decrypt(cls, ciphertext, private_key):&#10;        &quot;&quot;&quot;&#10;        :type ciphertext: str | bytes&#10;        :type private_key: str | bytes&#10;        :rtype: str&#10;        &quot;&quot;&quot;&#10;        ciphertext = base64.b64decode(ciphertext)&#10;        sentinel = Random.new().read(SHA.digest_size)&#10;        cipher = Cipher.new(RSA.importKey(private_key))&#10;        return cipher.decrypt(ciphertext, sentinel).decode()&#10;$end$" description="" toReformat="false" toShortenFQNames="true">
    <variable name="end" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="Python" value="true" />
      <option name="Python_Class" value="false" />
    </context>
  </template>
  <template name="hh:python:encoding" value="# encoding=$charset$&#10;$end$" description="" toReformat="false" toShortenFQNames="true">
    <variable name="charset" expression="" defaultValue="&quot;utf-8&quot;" alwaysStopAt="true" />
    <variable name="end" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="Python" value="true" />
      <option name="Python_Class" value="false" />
    </context>
  </template>
</templateSet>